#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <iostream>
#include <float.h>

// =================================================================================
// Tiled 2D Convolution 커널 (공유메모리)
// 입력:  input [N, C, H, W] 배치안입력피쳐맵수,입력피쳐맵채널수,입력피쳐맵높이,입력피쳐맵폭
// weight: weight [Kout, C, Kh, Kw] 출력피쳐맵채널수,입력피쳐맵채널수,마스크높이,마스크폭
// bias:   bias [Kout] 편향벡터는출력피쳐맵의채널수만큼의크기를가짐
// 출력:  output [N, Kout, Ho, Wo] 입력과동일한배치크기,출력피쳐맵채널수,컨볼루션결과높이,컨볼루션결과폭
// =================================================================================


__global__ void tiled_conv2d_kernel(
    const float* __restrict__ input,
    const float* __restrict__ weight, // 커널은임의의스레드마다컨볼루션계산시매번사용해야함
    const float* __restrict__ bias,   // 각각의스레드가매번커널을전역메모리에서불러오면레이턴시증가
    float* __restrict__ output,       // 적은저장리소스를가진공유메모리에계속저장되어있으면리소스낭비
    int N, int C, int H, int W,       // 따라서커널(마스크)의원소들은상수메모리에저장하는것으로함
    int Kout, int Kh, int Kw,
    int pad, int stride)
{
    // 아웃풋피쳐맵이그것의행과열방향으로몇개의픽셀을가지고있는지계산
    // 이시점에서결국하나의스레드가아웃풋피쳐맵에속한하나의픽셀을담당하게됨을염두해둠
    // 패딩은상하좌우시작끝에동일한크기만큼적용한다고가정
    int Ho = ((pad + H + pad) - Kh) / stride + 1; // 행, 높이, y축, 상하동일량패딩
    int Wo = ((pad + W + pad) - Kw) / stride + 1; // 열, 너비, x축, 좌우동일량패딩
    
    // 전역메모리(DRAM/HBM)에저장되어있는입력피쳐맵안의리셉티브필드(버퍼)의픽셀들을
    // 공유메모리(SRAMonGPUchip)으로가져와야하고이때사용해야할공유메모리의크기를지정해야함
    // 출력타일의한픽셀을계산하는각각의스레드는커널만큼의크기를가진리셉티브필드(버퍼)를가져와야함
    // 이때중요한건한스레드와그인접스레드가가져와야할픽셀들은스트라이드가커널의폭에비해서작은이상
    // 겹쳐질수밖에없고,겹쳐지는구체적인크기가바로커널의폭에서스트라이드의크기를뺀것임
    // 그렇다면,겹쳐지지않는크기는스트라이드의크기그자체이므로
    // 첫번째스레드가컨볼루션해야할픽셀들을커널의폭만큼공유메모리로가져와야하고
    // 추가적으로스트라이드만큼픽셀들도공유메모리로(블록안에속한스레드의개수-1)의횟수만큼가져와야함
    // 출력피쳐맵의파티션인타일의각픽셀들에커널이하나씩대응되고,시작픽셀부터끝픽셀로이동함에따라서
    // 이렇게커널들을스트라이트만큼겹쳐서이어붙이게되면최종적인타일당공유메모리의영역이정해짐
    // TILE_HEIGHT->blockDim.y,TILE_WIDTH->blockDim.x로대신하면
    // 자동적으로타일하나에대한계산이온전히스레드블록하나에의해서만수행된다.
    extern __shared__ float tile[];  //모든스레드블록이,전용동적메모리구역을하니씩받음
    int Sh = Kh + stride * (blockDim.y - 1); // 행, 높이, y축
    int Sw = Kw + stride * (blockDim.x - 1); // 열, 너비, x축
 
    // 위와같이공유메모리의영역을할당한이후에는
    // 스레드블록들과그것들각각에속한스레드들의전역좌표를알아내야지
    // 전역메모리인(DRAM/HBM)에저장되어있는,리셉티브필드(버퍼)의픽셀들을공유메모리로불러올수있음
    // 쿠다커널의각스레드들은서로서로단하나의베이스포인터float*input을동일하게사용함에도불구하고
    // 자신들의블록인덱스와스레드인덱스로계산된,서로다른오프셋을더함으로써
    // 스레드및그인접스레드들이읽고쓸전역메모리(DRAM/HBM)셀들을정확하게지정함
    // 스레드블록의좌표에각블록이가진스레드의개수의개수를곱하면각블록이가진첫번째스레드의글로벌좌표임
    int bx = blockIdx.x * blockDim.x;
    int by = blockIdx.y * blockDim.y;
    int tx = threadIdx.x;  // [0, blockDim.x)
    int ty = threadIdx.y;  // [0, blockDim.y)
    int n  = blockIdx.z; //배치인덱스

    // 구체적으로컨볼루션의절차가어떻게이루어지는지생각해보면
    // 4차원텐서인배치에서3차원텐서인입력이미지를꺼내면,입력이미지당
    // 서로가진성분은다르지만,동일한폭과높이를가진마스크들이,입력채널의개수만큼존재하고
    // 그마스크들이,상응하는각각의입력피쳐맵의채널에,컨볼루션을출력채널의개수만큼반복하고
    // 각출력채널의산출은,각반복횟수당모든입력채널들에대한,컨볼루션결과를합치는것임
    // 공유메모리로로딩할때,입력채널수에대해서뿐만아니라,출력채널수에대해서도순회해야함
    // 출력픽셀하나를얻기위한공유메모리에서커널크기만큼의영역(=리셉티브필드,버퍼)
    // 병렬로픽셀들을로딩하고,블록이사용하기로한공유메모리의영역을타일이겹쳐지지않게이어붙여서커버
    // 블록안의모든스레드들이하나의input포인터로로딩하고그들의전체수만큼의오프셋으로밀어서
    // 인접블록안의모든스레드들로이동하고,또다시이들이단일input포인터로로딩하고..
    // 결과적으로마스크가쓸고지나가는영역의입력피쳐맵의픽셀들을모조리공유메모리에완전히로드
    // 신호처리에서,LTI필터의개념을생각해봤을때,특정한시점n에서의출력탭y[n](출력픽셀하나)을
    // 얻기위해서일지라도,입력탭들이x[-]여러개,정확하게는커널의폭만큼의시점들에서x[-]들이필요함
    // 컨볼루션(사실은크로스코얼레이션)이적용될입력신호의인덱스는일반적으로형태가x[n+m]
    // 스트라이드stride와패딩pad를도입하면,x[n*stride+m-pad]로주어짐,여기서n은시작점
    // 병렬디지털신호처리에서시작점n은버퍼(리셉티브필드)들의첫번째스레드의전역인덱스이고,n=bx
    // m은병렬처리시,순회하는것이아닌,한번에버퍼(리셉티브필드)안의모든탭x[-]을로딩함,m=tx
    // 전역피쳐맵위에서의좌표로전역메모리를평탄화된방식으로참조해서실수형변수view로복사한후
    // 타일안의스레드좌표를평탄화된방식으로참조해서view안의값을대입
    for (int k = 0; k < Kout; ++k) { //출력채널별순회
        for (int c = 0; c < C; ++c) { //입력채널별순회
            // 블록안에있는모든스레드가로딩에참여했을때,타일안의모든출력픽셀들이필요한
            // 리셉티브필드(버퍼)안의모든픽셀(탭)들을빠짐없이로딩했는지를확인하는로직이필요하고
            // 그렇지않으면,재로딩해서,출력픽셀당필요한공유메모리를완전하게채우는로직추가
            // 커널의크기는리셉티브필드의크기와동일,커널이커지면리셉티브필드의크기가커져서
            // 로딩해야할픽셀(탭)수가증가해서,모든픽셀을로딩했을때,L1캐시메모리로스
            int numRowIter = (Sh + blockDim.y - 1) / blockDim.y; #ceil
            int numColIter = (Sw + blockDim.x - 1) / blockDim.x; #ceil
            for (int ri = 0; ri < numRowIter; ++ri) {
                int i = ty + ri * blockDim.y;
                for (int cj = 0; cj < numColIter; ++cj) {
                    int j = tx + cj * blockDim.x;
                    if (i < Sh && j < Sw) {
                        int in_x = bx * stride + j - pad;
                        int in_y = by * stride + i - pad;
                        float v = 0.0f;
                        if (in_x >= 0 && in_x < W && in_y >= 0 && in_y < H) {
                            v = input[n*C*H*W + c*H*W + in_y*W + in_x];
                        }
                        //tile의인덱스는블록안의스레드들의인덱스들이되,블록들을병렬로보는인덱스
                        tile[i * Sw + j] = v;
                    }
                }
            }
            __syncthreads();
            
            // 입출력채널순회를하는이중반복문안에서컨볼루션을타일별로공유메모리에서수행하더라도
            // 결과인출력타일을적어넣는곳은전역메모리이기때문에그리드안에서스레드의좌표를적어야함
            int out_x = bx + tx; 
            int out_y = by + ty;
            if (out_x < Wo && out_y < Ho) { //전역경계조건
                float sum = bias[k]; // 출력피쳐맵의채널별편향초기값
                for (int i = 0; i < Kh; ++i) { //커널의행(높이)방향순회
                    for (int j = 0; j < Kw; ++j) { //커널의열(폭)방향순회
                        // ty와tx가블록내에서계산할출력픽셀의위치(행·열 오프셋)라고한다면
                        // i와j는그출력픽셀을계산하기위해커널(필터)내에서반복해야할상대적오프셋
                        float val = tile[(ty*stride + i) * Sw + (tx*stride + j)];
                        float w = weight[k*C*Kh*Kw + c*Kh*Kw + i*Kw + j];
                        sum += val * w;
                    }
                }
                output[n*Kout*Ho*Wo + k*Ho*Wo + out_y*Wo + out_x] = sum;
            }
            __syncthreads(); // 다음 채널 전환 대기
        }
    }
}
